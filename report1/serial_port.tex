%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%												    %
%	PROTOCOLO LIGACAO DADOS						    %
%												    %
%	Novembro 2015								    %
%												    %
%	Angela Cardodo e Bruno Madeira					%
%   											    %	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt,a4paper,reqno]{report}
\linespread{1.2}

\usepackage[active]{srcltx}    
\usepackage{graphicx}
\usepackage{amsthm,amsfonts,amsmath,amssymb,indentfirst,mathrsfs,amscd}
\usepackage[mathscr]{eucal}
\usepackage{tensor}
\usepackage[utf8x]{inputenc}
\usepackage[portuges]{babel}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\setlist{nolistsep}
\usepackage{comment} 
\usepackage{tikz}
\usepackage[numbers,square, comma, sort&compress]{natbib}
\usepackage[nottoc,numbib]{tocbibind}
%\numberwithin{figure}{section}
\numberwithin{equation}{section}
\usepackage{scalefnt}
\usepackage[top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
%\usepackage{tweaklist}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}%
%	\setlength{\itemsep}{0pt}}
%\renewcommand{\enumhook}{\setlength{\topsep}{0pt}%
%	\setlength{\itemsep}{0pt}}
%\usepackage[colorlinks]{hyperref}
\usepackage{MnSymbol}
%\usepackage[pdfpagelabels,pagebackref,hypertexnames=true,plainpages=false,naturalnames]{hyperref}
\usepackage[naturalnames]{hyperref}
\usepackage{enumitem}
\usepackage{titling}
\newcommand{\subtitle}[1]{%
	\posttitle{%
	\par\end{center}
	\begin{center}\large#1\end{center}
	\vskip0.5em}%
}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{caption}
\usepackage{etoolbox}% http://ctan.org/pkg/etoolbox
\usepackage{complexity}

\usepackage[official]{eurosym}

\def\Cpp{C\raisebox{0.5ex}{\tiny\textbf{++}}}

\makeatletter
\def\@makechapterhead#1{%
  %%%%\vspace*{50\p@}% %%% removed!
  {\parindent \z@ \raggedright \normalfont
    \ifnum \c@secnumdepth >\m@ne
        \huge\bfseries \@chapapp\space \thechapter
        \par\nobreak
        \vskip 20\p@
    \fi
    \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    \vskip 40\p@
  }}
\def\@makeschapterhead#1{%
  %%%%%\vspace*{50\p@}% %%% removed!
  {\parindent \z@ \raggedright
    \normalfont
    \interlinepenalty\@M
    \Huge \bfseries  #1\par\nobreak
    \vskip 40\p@
  }}
\makeatother

\usepackage[toc,page]{appendix}

\addto\captionsportuges{%
  \renewcommand\appendixname{Anexo}
  \renewcommand\appendixpagename{Anexos}
}

\addto\captionsportuges{%
  \renewcommand\abstractname{\huge Sumário}  
}

\usepackage{verbatim}
\usepackage{color}
\definecolor{darkgray}{rgb}{0.41, 0.41, 0.41}
\definecolor{green}{rgb}{0.0, 0.5, 0.0}
\usepackage{listings}
\lstset{language=C++, 
    basicstyle=\linespread{0.8}\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
	showstringspaces=false,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
	identifierstyle=\color{darkgray}\ttfamily,
    morecomment=[l][\color{magenta}]{\#},
	tabsize=4,
    breaklines=true
}

\begin{document}

\input{./title.tex}


%%%%%%%%%%%
% SUMARIO %
%%%%%%%%%%%
\begin{abstract}
	
TODO: Parágrafo sobre contexto.

TODO: Parágrafo sobre conclusões.

\end{abstract}

\tableofcontents


%%%%%%%%%%%%%%
% INTRODUCAO %
%%%%%%%%%%%%%%
\chapter{Introdução}

TODO: Indicação dos objectivos do trabalho e do relatório; descrição da lógica do relatório com indicações sobre o tipo de informação que poderá ser encontrada em cada uma secções seguintes.

Relatório relativo ao primeiro trabalho prático de Redes de Computadores que consiste na implementação de uma aplicação que transfere imagens entre dois computadores fazendo uso da porta-série. A aplicação deve usar um protocolo de ligação de dados \emph{Stop N Wait ARQ} híbrido que deve assegurar a fiabilidade  da transmissão mesmo em caso de desconexão. Deve também usar um protocolo de aplicação que é responsável pelo envio da imagem. O código desenvolvido deve ser estruturado em camadas, respeitando o princípio de encapsulamento, de modo a assegurar cada protocolo funciona de forma independente.
	
	O trabalho foi utilizando a linguagem de programação C num ambiente com um sistema operativo baseado em Linux. Para testes foi usada uma porta-seire XPTO???.
	
	Este relatório visa reportar qual o estado final da aplicação desenvolvia, clarificar detalhes do processo de implementação/código e a opinião dos estudantes face ao projecto realizado.
	
	Do capítulo 2 ao 4 são expostas as estruturas e os mecanismos implementados na concepção da aplicação sem incidir em detalhes específicos destes.
	
	Os capítulos 5 e 6 incidem sobre as particularidades da implementação dos protocolos usados.
	
	O capítulo 7 apresenta os testes efectuados sobre a aplicação.
	
	O 
	
	
%%%%%%%%%%%%%%%
% ARQUITETURA %
%%%%%%%%%%%%%%%
\chapter{Arquitetura}

TODO:blocos funcionais e interfaces


%%%%%%%%%%%%%%%%%%%%
% ESTRUTURA CODIGO %
%%%%%%%%%%%%%%%%%%%%
\chapter{Estrutura do código}

TODO: APIs, principais estruturas de dados, principais funções e sua relação com a arquitetura


%%%%%%%%%%%%%
% CASOS USO %
%%%%%%%%%%%%%
\chapter{Casos de uso principais}

TODO: identificação; sequências de chamada de funções


%%%%%%%%%%%%%%%%%%
% LIGACAO LOGICA %
%%%%%%%%%%%%%%%%%%
\chapter{Protocolo de ligação lógica}

Para implementar o protocolo de ligação lógica, seguimos as indicações do enunciado do projeto. Sendo assim, usamos a variante \emph{Stop and Wait}, o que significa que o Emissor, após cada mensagem, aguarda uma resposta do Recetor antes de enviar a mensagem seguinte. Isto significa, entre outras coisas, que podemos utilizar uma numeração módulo 2 para as mensagens, dado que nunca temos mais do que 2 mensagens em jogo (aquela que foi enviada e a que se pretende enviar de seguida).

O interface deste protocolo tem 5 funções:
\begin{itemize}
\item \verb|int llopen(app_status_type status)| - abre a porta de série para comunicação, o parâmetro indica se é o Emissor ou o Receptor quem chama a função, retorna o número da ligação de dados, ou -1 em caso de erro;
\item \verb|int llclose(int fd, int hard)| - termina a ligação no final da comunicação, o parâmetro fd é o número da ligação, o parâmetro hard indica que estamos numa situação de terminar à força após um erro, retorna 0 ou -1 consoante seja bem sucedida ou ocorra erro;
\item \verb|int llwrite(int fd, char *buffer, int length)| - dado um número de ligação e um array de dados com determinado comprimento, constrói a trama de acordo com as regras do protocolo e envia essa trama, retorna 0 ou -1 consoante seja bem sucedida ou ocorra erro;
\item \verb|int llread(int fd, char **buffer)| - dado um número de ligação e um apontador para um array de dados, lê os dados da porta e coloca-os no array, retorna 0 ou -1 consoante seja bem sucedida ou ocorra erro;
\item \verb|void set_basic_definitions(int nTries, char* port, int baudrate, int packetSize)| - consoante as preferências do utilizador, determina o número de tentativas em caso de timeout, a porta, o baudrate e o tamanho dos dados nos pacotes de dados, guardando estas informações na estrutura \verb|datalink|;
\end{itemize}

Estas funções utilizam a função \verb|update_state_machine| para determinar a cada instante o estado em que está. Ao chamar esta função são definidos os estados finais, e só depois disso, quando um estado final é atingido, é feito o reset à máquina de estados.

Para obter a trama que pretende enviar é utilizada uma função \verb|getMessage| que tem como parâmetros o Emissor original, o tipo e o número da trama e o array de caracteres onde será colocada a flag e o cabeçalho da trama. Posteriormente a estes bytes, em tramas de Informação, serão adicionados os dados e o respetivo BCC2. Nas restantes tramas, é apenas reutilizada a flag que está na primeira posição do array. A sua especificação pode ser encontrada no Anexo~\ref{tramas}. 

TODO:

ligação de dados assíncrona
vmin=0 e ???min=0 -> read retorna de imediato -> e usado um ciclo -> blablabla

paridade usada foi XPTO, e possivel alterala no codigo

alarm

%%%%%%%%%%%%%
% APLICACAO %
%%%%%%%%%%%%%
\chapter{Protocolo de aplicação}

TODO: identificação dos principais aspectos funcionais; descrição da estratégia de implementação destes aspectos com apresentação de extractos de código

foi implementada de acordo com o enunciado.

a aplicação guarda o tamanho de imagem e o numero de pacotes ja enviados/recebidos

envia Start
recebe Start

envia info pode enviar pacotes de tamanho maximo definido pelo utilizador
recebe info

envia end
recebe end


%%%%%%%%%%%%%
% VALIDACAO %
%%%%%%%%%%%%%
\chapter{Validação}

TODO: descrição dos testes efectuados com apresentação quantificada dos resultados, se possível

foram realizados testes nas aulas práticas e fora destas usando uma porta-série.

foram realizados testes nas máquinas virtuais usadas para desenvolver a aplicação.

??? +


%%%%%%%%%%%%%%%
% VALORIZACAO %
%%%%%%%%%%%%%%%
\chapter{Elementos de valorização}

\section{Registo de ocorrências}

A camada de ligação de dados regista o número de tramas do tipo I e REJs recebidas/enviadas e o número de ocorrências de timeouts de uma transmissão. A informação fica registada numa variável do tipo \verb|occurrences_Log| e pode ser acedida pela componente de interface através do método \verb|get_occurrences_log|.

\section{Definições básicas}

O utilizador pode definir qual o \verb|baudrate| a usar, o \verb|packetSize| (numero de bytes máximos que envia da imagem em cada trama I antes de se realizar o stuffing) e o número máximo de tentativas consecutivas de reconexão.
Uma vez escolhidas as opções o intervalo de duração de um timeout é calculado em função do \verb|baudrate| e do \verb|packetSize| escolhidos pelo utilizador como se pode verificar no anexo \ref{setbasicdefinitions}. Na nossa implementação o receptor pode e deve configurar o \verb|baudrate| e \verb|packetSize| iguais aos do transmissor, pois, apesar de estes não serem usados na prática pelo receptor, são necessários para calcular um intervalo de timeout que seja fiável face às definições do transmissor.

\section{Gerador aleatório de erros}
São gerados erros aleatoriamente nas tramas enviadas pelo transmissor. São gerados erros no cabeçalho e de nos dados. Estes ocorrem de forma independente e são gerados respectivamente pelas funções \verb|randomErrorCabe| e \verb|randomErrorData|. A frequência destes erros é defina a partir das constantes \verb|CABE_PROB| e \verb|DATA_PROB| que representam quantas tramas são enviadas por cada um que apresenta um erro do tipo correspondente. Pode ser verificada a função \verb|randomErrorData| no anexo \ref{randomErrorData}. A \verb|randomErrorCabe| não foi incluída em anexo uma vez que é bastante semelhante à \verb|randomErrorData|.

\section{Representação do progresso}
Na AppProtocol.c, quando a aplicação está enviar/receber uma imagem, trata imprimir na consola a quantidade de bytes enviados/recebidos e quantos faltam para receber/enviar a imagem na totalidade. Este display (impressão na consola) é actualizado cada vez que um pacote é enviado/recebido na totalidade se já tiver passado um tempo mínimo definido na constante \verb|UPDATE_DISPLAY_MIN_TIME_INTERVAL| desde a ultima actualização de display de modo a evitar que ocorra com elevada frequência o que poderia tornar difícil a sua leitura ou afectar a leitura/recepção de tramas.


%%%%%%%%%%%%%%
% CONCLUSOES %
%%%%%%%%%%%%%%
\chapter{Conclusões}

TODO: síntese da informação apresentada nas secções anteriores; reflexão sobre os objectivos de aprendizagem alcançados


%%%%%%%%%%%%%%%%
% BIBLIOGRAPHY %
%%%%%%%%%%%%%%%%
\bibliographystyle{IEEEtran}
\bibliography{rabb,refs}

\begin{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APENDICE - CODIGO FONTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Código Fonte}

\begin{lstlisting}
int llopen(app_status_type status)
{
	int fd;

	if (open_tio(&fd, 0, 0) != OK) {
		printf("\nERROR: Could not open terminal\n");
		return -1;
	}
	occ_log.num_of_Is = 0;
	occ_log.total_num_of_timeouts= 0;
	occ_log.num_of_REJs			 = 0;
	if (status == APP_STATUS_TRANSMITTER)
	{
		app_status = APP_STATUS_TRANSMITTER;
		if( llopen_transmitter(fd) != OK) {
			close_tio(fd);
			return -1;
		};
	}
	else if (status == APP_STATUS_RECEIVER)
	{
		app_status = APP_STATUS_RECEIVER;
		if( llopen_receiver(fd) != OK) {
			close_tio(fd);
			return -1;
		};
	}
	else
	{
		printf("\nWARNING(llo):invalid app_status found on llopen().\n");
		close_tio(fd);
		return 1;
	}
	return fd;
}
\end{lstlisting}

\section{Função set\_basic\_definitions em DataLinkProtocol.c}
\label{setbasicdefinitions}
\begin{lstlisting}
void set_basic_definitions(int number_of_tries_when_failing, char* port, int baudrate, int packetSize)
{
	DEBUG_SECTION(DEBUG_PRINT_SECTION_NUM,
		printf("\n-section1-");
	sleep(1);
	);

	signal(SIGALRM, timeout_alarm_handler);
	
	int realbauds[20] = {0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800};
	int realBaudrate;
	if (baudrate <= 15) realBaudrate = realbauds[baudrate];
	else realBaudrate = realbauds[baudrate - 4081];
	
	int timeout_in_seconds = ((packetSize + 4 + 1) * 2 + 5) / (realBaudrate / 8) + 1;
	printf("size: %d\n", packetSize);
	printf("baudrate: %d\n", realBaudrate);
	printf("timeout: %d\n", timeout_in_seconds);
	link_layer_data.timeout = timeout_in_seconds;
	link_layer_data.numTransmissions = number_of_tries_when_failing;
	if (port_name_was_set == NO) { strcpy(link_layer_data.port, port); port_name_was_set = YES; }
	link_layer_data.baudRate = baudrate;
}
\end{lstlisting}

%-------------------------------------------------------------------------------------------------------------------------------------------------
\section{Função randomErrorData em DataLinkProtocol.c }
\label{randomErrorData}
\begin{lstlisting}
void randomErrorData(char* trama, int data_size) {	
	int trama_byte;
	if (DATA_PROB > 0) {
		int data_error = rand() % DATA_PROB;
		if (data_error == 0) {
			trama_byte = rand() % data_size;	// escolher o byte de erro na zona dos dados da trama
			trama[trama_byte]++;			// o erro e incrementar o byte escolhido
		}
	}
}
\end{lstlisting}
%-------------------------------------------------------------------------------------------------------------------------------------------------




\chapter{Tipos de Tramas Usadas}
\label{tramas}

As tramas que utilizamos podem ser de três tipos:
\begin{itemize}
	\item Informação (I) - transportam dados;
	\item Supervisão (S) - são usadas para iniciar e terminar a transmissão, assim como para responder a tramas do tipo I;
	\item Não Numeradas (U) - são usadas para responder a tramas de início e fim de transmissão.
\end{itemize}

Todas as tramas são delimitadas pelas \emph{Flags} F - 01111110. Além disso, independentemente do tipo da trama, o cabeçalho é sempre o mesmo conjunto de 3 bytes:
\begin{enumerate}
	\item A - Campo de Endereço - 00000011 em comandos enviados pelo Emissor e respostas enviadas pelo Receptor, 00000001 na situação inversa;
	\item C - Campo de Controlo:
		\begin{itemize}
			\item tramas I - 00S00000, onde S é o bit que identifica a trama;
			\item tramas SET (\emph{set up}) - 00000111;
			\item tramas DISC (\emph{disconnect})- 00001011;
			\item tramas UA (\emph{unnumbered acknowledgment}) - 00000011;
			\item tramas RR (\emph{positive acknowledgment}) - 00R00001, onde R identifica a trama;
			\item tramas REJ (\emph{negative acknowledgment}) - 00R00101, onde R identifica a trama;
		\end{itemize}
	\item BCC1 (\emph{Block Check Character}) - Campo de Proteção do Cabeçalho - é obtido realizando a disjunção exclusiva bit a bit de A e C.
\end{enumerate} 

Se se tratar de uma trama I, após o cabeçalho temos:
\begin{itemize}
	\item $\text{D}_{\text{1}}, \text{D}_{\text{2}}, \ldots, \text{D}_{\text{N}}$ - bytes de dados;
	\item BCC2 - Campo de Proteção dos Dados - calculado de forma que exista um número par de 1s em cada bit dos dados, incluindo o BCC2.
\end{itemize}

As restantes tramas apenas têm o respetivo cabeçalho delimitado por flags.


\end{appendices}

\end{document}
